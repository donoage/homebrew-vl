#!/usr/bin/env python3

import sys
import os
import platform
import subprocess
import datetime
import webbrowser
import time
import glob
import shutil
import json
import tempfile

# VL Script Version 3.0.15 - Fix PowerShell syntax errors in Windows browser handling

def print_usage():
    """Print usage instructions."""
    print("Usage: vl TICKER")
    print("Example: vl AAPL")
    sys.exit(1)

def store_window_ids(window_ids, browser_name, system_type="windows"):
    """Store window IDs in a temp file for future reuse."""
    try:
        # Create a consistent temp directory path
        temp_dir = os.path.join(tempfile.gettempdir(), "vl_app")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Create the file path
        temp_file = os.path.join(temp_dir, f"vl_{system_type}_windows.json")
        
        # Store data with browser name and timestamp
        data = {
            "window_ids": window_ids,
            "browser": browser_name,
            "timestamp": time.time(),
            "count": len(window_ids)
        }
        
        # Write to file
        with open(temp_file, "w") as f:
            json.dump(data, f)
            
        print(f"Stored {len(window_ids)} window IDs for future use")
        return True
    except Exception as e:
        print(f"Error storing window IDs: {e}")
        return False

def clear_stored_window_ids(system_type="windows"):
    """Clear stored window IDs when they're no longer valid."""
    try:
        temp_dir = os.path.join(tempfile.gettempdir(), "vl_app")
        temp_file = os.path.join(temp_dir, f"vl_{system_type}_windows.json")
        
        if os.path.exists(temp_file):
            os.remove(temp_file)
            print(f"Cleared stored window IDs for {system_type}")
        return True
    except Exception as e:
        print(f"Error clearing window IDs: {e}")
        return False

def get_stored_window_ids(system_type="windows", max_age_seconds=3600):
    """Retrieve previously stored window IDs if they exist and aren't too old."""
    try:
        # Get the temp file path
        temp_dir = os.path.join(tempfile.gettempdir(), "vl_app")
        temp_file = os.path.join(temp_dir, f"vl_{system_type}_windows.json")
        
        # Check if file exists
        if not os.path.exists(temp_file):
            return None
            
        # Read the data
        with open(temp_file, "r") as f:
            data = json.load(f)
            
        # Check if data is too old
        if time.time() - data.get("timestamp", 0) > max_age_seconds:
            print("Stored window IDs are too old, will detect new ones")
            return None
            
        # Check if we have enough window IDs
        window_ids = data.get("window_ids", [])
        if len(window_ids) < 4:
            print(f"Only found {len(window_ids)} stored window IDs, need at least 4")
            return None
            
        print(f"Using {len(window_ids)} previously stored window IDs")
        return {
            "window_ids": window_ids,
            "browser": data.get("browser", "unknown")
        }
    except Exception as e:
        print(f"Error retrieving stored window IDs: {e}")
        return None

def main():
    """Main function."""
    # Check if ticker argument is provided
    if len(sys.argv) < 2:
        print_usage()
    
    # Get the ticker from command line argument
    ticker = sys.argv[1].upper()
    print(f"Using ticker: {ticker}")
    
    # Get today's date in YYYY-MM-DD format
    today = datetime.date.today().strftime("%Y-%m-%d")
    print(f"Using today's date: {today}")
    
    # Calculate dates for different timeframes
    three_months_ago = (datetime.date.today() - datetime.timedelta(days=90)).strftime("%Y-%m-%d")
    one_month_ago = (datetime.date.today() - datetime.timedelta(days=30)).strftime("%Y-%m-%d")
    one_week_ago = (datetime.date.today() - datetime.timedelta(days=7)).strftime("%Y-%m-%d")
    
    # Construct URLs with the provided ticker and dates
    url1 = f"https://www.volumeleaders.com/Chart?StartDate={three_months_ago}&EndDate={today}&Ticker={ticker}&MinVolume=0&MaxVolume=2000000000&MinDollars=500000&MaxDollars=300000000000&MinPrice=0&MaxPrice=100000&DarkPools=-1&Sweeps=-1&LatePrints=-1&SignaturePrints=0&VolumeProfile=0&Levels=5&TradeCount=5&VCD=0&TradeRank=-1&IncludePremarket=1&IncludeRTH=1&IncludeAH=1&IncludeOpening=1&IncludeClosing=1&IncludePhantom=1&IncludeOffsetting=1"
    
    url2 = f"https://www.volumeleaders.com/Chart?StartDate={one_month_ago}&EndDate={today}&Ticker={ticker}&MinVolume=0&MaxVolume=2000000000&MinDollars=500000&MaxDollars=300000000000&MinPrice=0&MaxPrice=100000&DarkPools=1&Sweeps=1&LatePrints=-1&SignaturePrints=0&VolumeProfile=0&Levels=5&TradeCount=5&VCD=0&TradeRank=-1&IncludePremarket=1&IncludeRTH=1&IncludeAH=1&IncludeOpening=1&IncludeClosing=1&IncludePhantom=1&IncludeOffsetting=1"
    
    url3 = f"https://www.volumeleaders.com/Chart?StartDate={one_month_ago}&EndDate={today}&Ticker={ticker}&MinVolume=0&MaxVolume=2000000000&MinDollars=500000&MaxDollars=300000000000&MinPrice=0&MaxPrice=100000&DarkPools=-1&Sweeps=-1&LatePrints=-1&SignaturePrints=0&VolumeProfile=0&Levels=5&TradeCount=5&VCD=0&TradeRank=-1&IncludePremarket=1&IncludeRTH=1&IncludeAH=1&IncludeOpening=1&IncludeClosing=1&IncludePhantom=1&IncludeOffsetting=1"
    
    url4 = f"https://www.volumeleaders.com/Chart?StartDate={one_week_ago}&EndDate={today}&Ticker={ticker}&MinVolume=0&MaxVolume=2000000000&MinDollars=500000&MaxDollars=300000000000&MinPrice=0&MaxPrice=100000&DarkPools=1&Sweeps=1&LatePrints=-1&SignaturePrints=0&VolumeProfile=0&Levels=5&TradeCount=5&VCD=0&TradeRank=-1&IncludePremarket=1&IncludeRTH=1&IncludeAH=1&IncludeOpening=1&IncludeClosing=1&IncludePhantom=1&IncludeOffsetting=1"
    
    # Detect operating system
    system = platform.system()
    
    # Check if running in WSL
    is_wsl = False
    is_parallels_wsl = False
    if system == "Linux":
        try:
            with open('/proc/version', 'r') as f:
                version_info = f.read().lower()
                if 'microsoft' in version_info:
                    is_wsl = True
                    print("Detected Windows Subsystem for Linux (WSL)")
                    
                    # Check if running in Parallels
                    if os.path.exists('/mnt/c/Program Files/Parallels'):
                        is_parallels_wsl = True
                        print("Detected Parallels WSL environment")
        except:
            pass
    
    if system == "Darwin":  # macOS
        print("Detected macOS - Using AppleScript for window positioning")
        open_urls_macos(url1, url2, url3, url4)
    elif system == "Windows" or is_wsl:  # Windows or WSL
        if is_wsl:
            if is_parallels_wsl:
                print("Using Parallels WSL-specific browser opening method")
                open_urls_parallels_wsl(url1, url2, url3, url4)
            else:
                print("Using WSL-specific browser opening method")
                open_urls_wsl(url1, url2, url3, url4)
        else:
            print("Detected Windows - Opening URLs in default browser")
            open_urls_windows(url1, url2, url3, url4)
    else:  # Linux or other
        print(f"Detected {system} - Opening URLs in default browser")
        open_urls_default(url1, url2, url3, url4)

def get_screen_dimensions_macos():
    """Get screen dimensions on macOS using AppleScript."""
    applescript = '''
    tell application "Finder"
        set _bounds to bounds of window of desktop
        set screenWidth to item 3 of _bounds
        set screenHeight to item 4 of _bounds
        return screenWidth & "," & screenHeight
    end tell
    '''
    
    try:
        result = subprocess.run(["osascript", "-e", applescript], capture_output=True, text=True)
        if result.stdout.strip():
            dimensions = result.stdout.strip().split(',')
            if len(dimensions) == 2:
                screen_width = int(float(dimensions[0]))
                screen_height = int(float(dimensions[1]))
                return screen_width, screen_height
        
        # If we got here, try an alternative method
        applescript_alt = '''
        tell application "System Events"
            set _display to first display
            return (value of _display's width) & "," & (value of _display's height)
        end tell
        '''
        
        result = subprocess.run(["osascript", "-e", applescript_alt], capture_output=True, text=True)
        if result.stdout.strip():
            dimensions = result.stdout.strip().split(',')
            if len(dimensions) == 2:
                screen_width = int(float(dimensions[0]))
                screen_height = int(float(dimensions[1]))
                return screen_width, screen_height
                
        # If we still don't have dimensions, fallback to defaults
        return 2880, 1600
    except Exception as e:
        print(f"Error getting screen dimensions: {e}")
        # Fallback to default values
        return 2880, 1600

def open_urls_macos(url1, url2, url3, url4):
    """Open URLs on macOS with Chrome and position windows."""
    # Get screen dimensions
    screen_width, screen_height = get_screen_dimensions_macos()
    
    # Calculate half width and height
    half_width = screen_width // 2
    half_height = screen_height // 2
    
    print(f"Detected screen resolution: {screen_width}x{screen_height}")
    print(f"Window dimensions will be: {half_width}x{half_height}")
    
    # Make sure Chrome is running
    subprocess.run(["open", "-a", "Google Chrome"])
    time.sleep(0.5)
    
    # Enhanced method to check for browser windows
    # This will find ALL Chrome windows, not just ones with volumeleaders in the title
    applescript = '''
    try
        tell application "Google Chrome"
            set windowCount to count of windows
            
            # First try to find any VolumeLeaders windows
            set vlWindows to {}
            repeat with w in windows
                try
                    set tabCount to count of tabs of w
                    repeat with t from 1 to tabCount
                        set tabURL to URL of tab t of w
                        if tabURL contains "volumeleaders.com/Chart" then
                            set end of vlWindows to w
                            exit repeat
                        end if
                    end repeat
                on error
                    # Skip if we can't get the URL
                end try
            end repeat
            
            # If we found VolumeLeaders windows, return those count
            if (count of vlWindows) > 0 then
                return "volumeleaders:" & (count of vlWindows)
            end if
            
            # If not, just return the count of all windows with actual content
            set contentWindows to {}
            repeat with w in windows
                # Only consider windows that aren't tiny
                set winBounds to bounds of w
                set winWidth to item 3 of winBounds - item 1 of winBounds
                set winHeight to item 4 of winBounds - item 2 of winBounds
                
                if winWidth > 200 and winHeight > 200 then
                    set end of contentWindows to w
                end if
            end repeat
            
            return "any:" & (count of contentWindows)
        end tell
    on error errMsg
        return "error:" & errMsg
    end try
    '''
    
    result = subprocess.run(["osascript", "-e", applescript], capture_output=True, text=True)
    window_info = result.stdout.strip()
    
    window_count = 0
    window_type = "none"
    
    if window_info.startswith("volumeleaders:"):
        window_count = int(window_info.split(":")[1])
        window_type = "volumeleaders"
    elif window_info.startswith("any:"):
        window_count = int(window_info.split(":")[1])
        window_type = "any"
    elif window_info.startswith("error:"):
        print(f"Error checking for windows: {window_info}")
    
    print(f"Found {window_count} browser windows of type '{window_type}'")
    
    if window_count >= 1:
        print(f"Reusing {window_count} existing browser windows...")
        
        # Update existing windows
        applescript = f'''
        try
            tell application "Google Chrome"
                # Get the actual windows we'll be using
                set targetWindows to {{}}
                
                # First try to look for volumeleaders windows
                set vlWindows to {{}}
                repeat with w in windows
                    try
                        set tabCount to count of tabs of w
                        repeat with t from 1 to tabCount
                            set tabURL to URL of tab t of w
                            if tabURL contains "volumeleaders.com/Chart" then
                                set end of vlWindows to w
                                exit repeat
                            end if
                        end repeat
                    on error
                        # Skip if we can't get the URL
                    end try
                end repeat
                
                # If we found VolumeLeaders windows, use those first
                if (count of vlWindows) > 0 then
                    set targetWindows to vlWindows
                else
                    # Otherwise, just use any content windows
                    repeat with w in windows
                        # Only consider windows that aren't tiny
                        set winBounds to bounds of w
                        set winWidth to item 3 of winBounds - item 1 of winBounds
                        set winHeight to item 4 of winBounds - item 2 of winBounds
                        
                        if winWidth > 200 and winHeight > 200 then
                            set end of targetWindows to w
                        end if
                    end repeat
                end if
                
                # Close any excess windows beyond 4
                if (count of targetWindows) > 4 then
                    log "Found " & (count of targetWindows) & " windows, closing excess..."
                    repeat with i from 5 to (count of targetWindows)
                        close window i
                    end repeat
                    # Now we only have 4 windows
                    set targetWindows to items 1 through 4 of targetWindows
                end if
                
                # Log how many windows we're working with
                log "Using " & (count of targetWindows) & " windows"
                
                # Update windows and position them
                if (count of targetWindows) >= 1 then
                    # Window 1: Top-Left
                    set w to item 1 of targetWindows
                    set bounds of w to {{0, 23, {half_width}, {half_height}}}
                    set active tab index of w to 1
                    tell active tab of w to set URL to "{url1}"
                end if
                
                if (count of targetWindows) >= 2 then
                    # Window 2: Top-Right
                    set w to item 2 of targetWindows
                    set bounds of w to {{{half_width}, 23, {screen_width}, {half_height}}}
                    set active tab index of w to 1
                    tell active tab of w to set URL to "{url2}"
                end if
                
                if (count of targetWindows) >= 3 then
                    # Window 3: Bottom-Left
                    set w to item 3 of targetWindows
                    set bounds of w to {{0, {half_height}, {half_width}, {screen_height}}}
                    set active tab index of w to 1
                    tell active tab of w to set URL to "{url3}"
                end if
                
                if (count of targetWindows) >= 4 then
                    # Window 4: Bottom-Right
                    set w to item 4 of targetWindows
                    set bounds of w to {{{half_width}, {half_height}, {screen_width}, {screen_height}}}
                    set active tab index of w to 1
                    tell active tab of w to set URL to "{url4}"
                end if
                
                # Create any additional windows we need (if we found fewer than 4)
                if (count of targetWindows) < 4 then
                    # Create window 2 if needed
                    if (count of targetWindows) < 2 then
                        make new window with properties {{bounds:{{{half_width}, 23, {screen_width}, {half_height}}}}}
                        tell active tab of front window to set URL to "{url2}"
                        delay 0.3
                    end if
                    
                    # Create window 3 if needed
                    if (count of targetWindows) < 3 then
                        make new window with properties {{bounds:{{0, {half_height}, {half_width}, {screen_height}}}}}
                        tell active tab of front window to set URL to "{url3}"
                        delay 0.3
                    end if
                    
                    # Create window 4 if needed
                    if (count of targetWindows) < 4 then
                        make new window with properties {{bounds:{{{half_width}, {half_height}, {screen_width}, {screen_height}}}}}
                        tell active tab of front window to set URL to "{url4}"
                    end if
                end if
            end tell
            return "success"
        on error errMsg
            return "ERROR: " & errMsg
        end try
        '''
        
        result = subprocess.run(["osascript", "-e", applescript], capture_output=True, text=True)
        if result.stdout.strip().startswith("ERROR:"):
            print(f"Error updating windows: {result.stdout.strip()}")
        else:
            print(f"Successfully updated chart windows for {sys.argv[1].upper()}")
    else:
        # No existing windows found, create new ones
        print(f"Creating new chart windows for {sys.argv[1].upper()}...")
        
        applescript = f'''
        tell application "Google Chrome"
            # Window 1: Top-Left - 3 month chart
            make new window with properties {{bounds:{{0, 23, {half_width}, {half_height}}}}}
            tell active tab of front window to set URL to "{url1}"
            delay 0.3
            
            # Window 2: Top-Right - 1 month chart with dark pools and sweeps
            make new window with properties {{bounds:{{{half_width}, 23, {screen_width}, {half_height}}}}}
            tell active tab of front window to set URL to "{url2}"
            delay 0.3
            
            # Window 3: Bottom-Left - 1 month chart
            make new window with properties {{bounds:{{0, {half_height}, {half_width}, {screen_height}}}}}
            tell active tab of front window to set URL to "{url3}"
            delay 0.3
            
            # Window 4: Bottom-Right - 1 week chart with dark pools and sweeps
            make new window with properties {{bounds:{{{half_width}, {half_height}, {screen_width}, {screen_height}}}}}
            tell active tab of front window to set URL to "{url4}"
        end tell
        '''
        
        subprocess.run(["osascript", "-e", applescript])
        print(f"Successfully created chart windows for {sys.argv[1].upper()}")

def position_windows_powershell(window_ids, browser_path, urls, temp_dir=None):
    """
    Position windows using PowerShell with an alternative approach that works better on Windows 11.
    This positions windows by their process IDs.
    """
    try:
        # Create PowerShell script for window positioning
        ps_script = '''
        Add-Type -AssemblyName System.Windows.Forms
        
        # Get screen dimensions
        $screen = [System.Windows.Forms.Screen]::PrimaryScreen
        $screenWidth = $screen.Bounds.Width
        $screenHeight = $screen.Bounds.Height
        
        # Calculate half dimensions
        $halfWidth = $screenWidth / 2
        $halfHeight = $screenHeight / 2
        
        # Define our positions (left, top, right, bottom)
        $positions = @(
            @(0, 0, $halfWidth, $halfHeight),
            @($halfWidth, 0, $screenWidth, $halfHeight),
            @(0, $halfHeight, $halfWidth, $screenHeight),
            @($halfWidth, $halfHeight, $screenWidth, $screenHeight)
        )

        # Add external DLL for window manipulation
        Add-Type @"
        using System;
        using System.Runtime.InteropServices;
        
        public class Win32 {
            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
            
            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);
            
            [DllImport("user32.dll")]
            public static extern IntPtr GetForegroundWindow();
            
            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool SetForegroundWindow(IntPtr hWnd);
            
            [DllImport("user32.dll")]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);
            
            [DllImport("user32.dll")]
            public static extern int GetWindowTextLength(IntPtr hWnd);
            
            [DllImport("user32.dll")]
            public static extern int GetWindowText(IntPtr hWnd, System.Text.StringBuilder lpString, int nMaxCount);
            
            [DllImport("user32.dll")]
            public static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
            
            public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);
            
            [StructLayout(LayoutKind.Sequential)]
            public struct RECT {
                public int Left;
                public int Top;
                public int Right;
                public int Bottom;
            }
        }
"@

        # First wait a bit for browser windows to initialize
        Write-Host "Waiting for browser windows to initialize..."
        Start-Sleep -Seconds 2
        
        # Try detecting windows by their title containing 'volumeleaders' first
        # This is more reliable than process IDs
        Write-Host "Looking for windows with 'volumeleaders' in title..."
        
        function Find-VolumeLeadersWindows {
            $windows = New-Object System.Collections.ArrayList
            
            $enumWindowsCallback = [Win32+EnumWindowsProc] {
                param(
                    [IntPtr]$hwnd,
                    [IntPtr]$lParam
                )
                
                # Get window text length
                $windowTextLength = [Win32]::GetWindowTextLength($hwnd)
                
                if ($windowTextLength -gt 0) {
                    # Get window title
                    $windowText = New-Object System.Text.StringBuilder($windowTextLength + 1)
                    [Win32]::GetWindowText($hwnd, $windowText, $windowText.Capacity) | Out-Null
                    
                    # Check for browser windows - first look for volumeleaders in title
                    $isVolumeLeaders = $windowText.ToString() -like "*volumeleaders*"
                    
                    # If it's a volumeleaders window or has certain browser keywords in the title
                    $isBrowserWindow = $isVolumeLeaders -or 
                                      $windowText.ToString() -like "*Chrome*" -or 
                                      $windowText.ToString() -like "*Edge*" -or
                                      $windowText.ToString() -like "*- Google Chrome" -or
                                      $windowText.ToString() -like "*- Microsoft Edge"
                    
                    if ($isBrowserWindow) {
                        $rect = New-Object Win32+RECT
                        [Win32]::GetWindowRect($hwnd, [ref]$rect) | Out-Null
                        
                        # Make sure this is a real window with size, not a tiny or invisible window
                        if (($rect.Right - $rect.Left) -gt 100 -and ($rect.Bottom - $rect.Top) -gt 100) {
                            $processId = 0
                            [Win32]::GetWindowThreadProcessId($hwnd, [ref]$processId) | Out-Null
                            
                            $windowInfo = @{
                                Handle = $hwnd
                                Title = $windowText.ToString()
                                ProcessId = $processId
                            }
                            [void]$windows.Add($windowInfo)
                        }
                    }
                }
                
                # Continue enumeration
                return $true
            }
            
            # Enumerate all windows
            [Win32]::EnumWindows($enumWindowsCallback, [IntPtr]::Zero) | Out-Null
            
            # Prioritize windows with "volumeleaders" in the title
            $volumeLeadersWindows = $windows | Where-Object { $_.Title -like "*volumeleaders*" }
            
            # If we found volumeleaders windows, use at most 4 of them
            if ($volumeLeadersWindows -and $volumeLeadersWindows.Count -gt 0) {
                return $volumeLeadersWindows | Select-Object -First 4
            }
            
            # If we don't have enough windows, just return all we found (up to 4)
            return $windows | Select-Object -First 4
        }
        
        # Find all VolumeLeaders windows
        $browserWindows = Find-VolumeLeadersWindows
        
        # Close excess browser windows if we found more than 4
        if ($browserWindows -and $browserWindows.Count -gt 4) {
            Write-Host "Found $($browserWindows.Count) browser windows, closing excess windows..."
            
            # Sort windows to close the newest ones first (assuming they're the extras)
            $windowsToClose = $browserWindows | Select-Object -Skip 4
            
            foreach ($window in $windowsToClose) {
                try {
                    # Try to close the window by sending Alt+F4
                    [Win32]::SetForegroundWindow($window.Handle) | Out-Null
                    Start-Sleep -Milliseconds 100
                    
                    # Send Alt+F4 to close the window
                    Add-Type -AssemblyName System.Windows.Forms
                    [System.Windows.Forms.SendKeys]::SendWait("%{F4}")
                    Start-Sleep -Milliseconds 200
                } catch {
                    Write-Host "Failed to close extra window: $_"
                }
            }
            
            # Update our list to only use the first 4 windows
            $browserWindows = $browserWindows | Select-Object -First 4
            Start-Sleep -Milliseconds 500
        }
        
        # If no windows found with title, then fallback to process IDs
        if (-not $browserWindows -or $browserWindows.Count -eq 0) {
            Write-Host "No windows found by title, falling back to process IDs..."
            
            # Array to store window handles by process IDs
            $processIds = @($args[0].Split(',') | ForEach-Object { [int]$_ })
            Write-Host "Looking for windows with process IDs: $processIds"
            
            function Find-WindowsByProcessId {
                $windows = New-Object System.Collections.ArrayList
                
                $enumWindowsCallback = [Win32+EnumWindowsProc] {
                    param(
                        [IntPtr]$hwnd,
                        [IntPtr]$lParam
                    )
                    
                    # Get window text length
                    $windowTextLength = [Win32]::GetWindowTextLength($hwnd)
                    
                    if ($windowTextLength -gt 0) {
                        # Get process ID for this window
                        $processId = 0
                        [Win32]::GetWindowThreadProcessId($hwnd, [ref]$processId) | Out-Null
                        
                        # Check if this window belongs to our browser processes
                        if ($processIds -contains $processId) {
                            $rect = New-Object Win32+RECT
                            [Win32]::GetWindowRect($hwnd, [ref]$rect) | Out-Null
                            
                            # Make sure this is a real window with size, not a tiny or invisible window
                            if (($rect.Right - $rect.Left) -gt 100 -and ($rect.Bottom - $rect.Top) -gt 100) {
                                # Get window title
                                $windowText = New-Object System.Text.StringBuilder($windowTextLength + 1)
                                [Win32]::GetWindowText($hwnd, $windowText, $windowText.Capacity) | Out-Null
                                
                                $windowInfo = @{
                                    Handle = $hwnd
                                    Title = $windowText.ToString()
                                    ProcessId = $processId
                                }
                                [void]$windows.Add($windowInfo)
                            }
                        }
                    }
                    
                    # Continue enumeration
                    return $true
                }
                
                # Enumerate all windows
                [Win32]::EnumWindows($enumWindowsCallback, [IntPtr]::Zero) | Out-Null
                
                return $windows
            }
            
            # Find browser windows by process ID
            $browserWindows = Find-WindowsByProcessId
            
            # Return error if we didn't find any windows by process ID
            if (-not $browserWindows -or $browserWindows.Count -eq 0) {
                Write-Host "Found 0 browser windows to position"
                return "no_windows_found"
            }
        }
        
        Write-Host "Found $($browserWindows.Count) browser windows to position"
        
        # Position each window
        for ($i = 0; $i -lt [Math]::Min($browserWindows.Count, $positions.Count); $i++) {
            $window = $browserWindows[$i]
            $pos = $positions[$i]
            
            $left = $pos[0]
            $top = $pos[1]
            $width = $pos[2] - $pos[0]
            $height = $pos[3] - $pos[1]
            
            Write-Host "Positioning window $i with title '$($window.Title)' to $left,$top,$width,$height"
            
            # Set as foreground window first
            [Win32]::SetForegroundWindow($window.Handle) | Out-Null
            
            # Move and resize window
            [Win32]::MoveWindow($window.Handle, $left, $top, $width, $height, $true) | Out-Null
            
            # Small delay to allow system to process
            Start-Sleep -Milliseconds 200
        }
        
        return "success"
        '''
        
        # Create a unique script name and directory that's definitely writable in WSL
        import tempfile
        
        if os.name == 'nt':  # Windows
            temp_dir = os.environ.get('TEMP')
            ps_path = os.path.join(temp_dir, f'vl_position_windows_{time.time()}.ps1')
            with open(ps_path, 'w') as f:
                f.write(ps_script)
                
            # Format process IDs as comma-separated string
            process_ids_str = ','.join(str(pid) for pid in window_ids)
            
            # Run PowerShell script with process IDs as argument
            result = subprocess.run(['powershell', '-ExecutionPolicy', 'Bypass', '-File', ps_path, process_ids_str], 
                                   check=True, capture_output=True, text=True)
            
            # Check for no_windows_found in output
            if "no_windows_found" in result.stdout:
                print("No windows were found, clearing stored window IDs")
                system_type = "windows"  # Default system type
                if "wsl" in platform.platform().lower():
                    system_type = "parallels_wsl" if os.path.exists('/mnt/c/Program Files/Parallels') else "wsl"
                clear_stored_window_ids(system_type)
                return False  # Signal failure so caller can handle it
            
            # Clean up the script file
            try:
                os.remove(ps_path)
            except:
                pass
        else:  # WSL or other Linux
            # For WSL, create a temporary file in a Windows-accessible location
            try:
                import shutil
                
                # Create a unique PS script filename
                ps_file_name = f'vl_position_{time.time()}.ps1'
                wsl_temp_path = f"/tmp/{ps_file_name}"
                win_path = f"C:\\Users\\Public\\{ps_file_name}"
                wsl_win_path = f"/mnt/c/Users/Public/{ps_file_name}"
                
                # Write script to temp file first
                with open(wsl_temp_path, 'w') as f:
                    f.write(ps_script)
                
                # Copy to Windows-accessible location
                shutil.copy(wsl_temp_path, wsl_win_path)
                
                # Format process IDs as comma-separated string
                process_ids_str = ','.join(str(pid) for pid in window_ids)
                
                # Run the script from Windows using the proper path
                cmd = f"cd /mnt/c && powershell.exe -ExecutionPolicy Bypass -File \"C:\\Users\\Public\\{ps_file_name}\" {process_ids_str}"
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
                
                # Check for no_windows_found in output - be more thorough in checking the stdout
                if result.stdout and ("no_windows_found" in result.stdout or "Found 0 browser windows" in result.stdout):
                    print("No windows were found, clearing stored window IDs")
                    system_type = "windows"  # Default system type
                    if "wsl" in platform.platform().lower():
                        system_type = "parallels_wsl" if os.path.exists('/mnt/c/Program Files/Parallels') else "wsl"
                    clear_stored_window_ids(system_type)
                    return False  # Signal failure so caller can handle it
                
                # Clean up temporary files
                try:
                    os.remove(wsl_temp_path)
                    os.remove(wsl_win_path)
                except:
                    pass
            except Exception as e:
                print(f"Error with WSL window positioning approach 1: {e}")
                print("Trying alternative approach for window positioning...")
                
                # Fallback to direct PowerShell command instead of script file
                try:
                    # Don't use the complex script approach; use a simpler direct command
                    # that's less prone to quoting issues
                    process_ids_str = ','.join(str(pid) for pid in window_ids)
                    
                    # Write a very simple PS script to position windows
                    simple_ps = f'''
                    Add-Type -AssemblyName System.Windows.Forms
                    $screen = [System.Windows.Forms.Screen]::PrimaryScreen
                    $w = $screen.Bounds.Width/2
                    $h = $screen.Bounds.Height/2
                    $pids = "{process_ids_str}".Split(",")
                    $windows = @()
                    foreach ($pid in $pids) {{
                        $proc = Get-Process -Id $pid -ErrorAction SilentlyContinue
                        if ($proc -and $proc.MainWindowHandle -ne [IntPtr]::Zero) {{
                            $windows += $proc
                        }}
                    }}
                    if ($windows.Count -gt 0) {{
                        $positions = @(
                            @(0, 0, $w, $h),
                            @($w, 0, $screen.Bounds.Width, $h),
                            @(0, $h, $w, $screen.Bounds.Height),
                            @($w, $h, $screen.Bounds.Width, $screen.Bounds.Height)
                        )
                        for ($i=0; $i -lt [Math]::Min($windows.Count, 4); $i++) {{
                            $win = $windows[$i].MainWindowHandle
                            $pos = $positions[$i]
                            # Use P/Invoke to position windows
                            # Code will be added here in a file-based approach
                        }}
                    }} else {{
                        Write-Host "No windows found with PIDs: {process_ids_str}"
                    }}
                    '''
                    
                    # Write to temp file
                    simple_ps_path = "/tmp/vl_simple_position.ps1"
                    with open(simple_ps_path, "w") as f:
                        f.write(simple_ps)
                    
                    # Copy to Windows-accessible location
                    win_simple_ps = "/mnt/c/Users/Public/vl_simple_position.ps1"
                    shutil.copy(simple_ps_path, win_simple_ps)
                    
                    # Execute the script
                    cmd = f"cd /mnt/c && powershell.exe -ExecutionPolicy Bypass -File C:\\Users\\Public\\vl_simple_position.ps1"
                    subprocess.run(cmd, shell=True)
                    
                    # Clean up
                    try:
                        os.remove(simple_ps_path)
                        os.remove(win_simple_ps)
                    except:
                        pass
                    
                except Exception as e2:
                    print(f"Alternative window positioning also failed: {e2}")
                    print("Window positioning could not be completed")
                    system_type = "windows"  # Default system type
                    if "wsl" in platform.platform().lower():
                        system_type = "parallels_wsl" if os.path.exists('/mnt/c/Program Files/Parallels') else "wsl"
                    clear_stored_window_ids(system_type)
                    return False
            
        return True
    except Exception as e:
        print(f"Error positioning windows: {e}")
        # Clear stored window IDs on error
        system_type = "windows"  # Default system type
        if "wsl" in platform.platform().lower():
            system_type = "parallels_wsl" if os.path.exists('/mnt/c/Program Files/Parallels') else "wsl"
        clear_stored_window_ids(system_type)
        return False

def open_urls_windows(url1, url2, url3, url4):
    """Open URLs on Windows."""
    try:
        # First try to find Chrome
        print("Looking for Chrome installation...")
        chrome_paths = [
            os.path.expandvars("%ProgramFiles%\\Google\\Chrome\\Application\\chrome.exe"),
            os.path.expandvars("%ProgramFiles(x86)%\\Google\\Chrome\\Application\\chrome.exe"),
            os.path.expandvars("%LocalAppData%\\Google\\Chrome\\Application\\chrome.exe"),
            # Add more potential paths if needed
        ]
        
        chrome_path = None
        for path in chrome_paths:
            if os.path.exists(path):
                chrome_path = path
                print(f"Found Chrome at: {chrome_path}")
                break
                
        # If Chrome not found, try to find Edge
        if not chrome_path:
            print("Chrome not found. Looking for Microsoft Edge...")
            edge_paths = [
                os.path.expandvars("%ProgramFiles(x86)%\\Microsoft\\Edge\\Application\\msedge.exe"),
                os.path.expandvars("%ProgramFiles%\\Microsoft\\Edge\\Application\\msedge.exe"),
                # Add more potential paths if needed
            ]
            
            for path in edge_paths:
                if os.path.exists(path):
                    chrome_path = path  # Use edge_path but keep the variable name for code reuse
                    print(f"Found Microsoft Edge at: {chrome_path}")
                    break
        
        browser_name = "Edge" if chrome_path and ("edge" in chrome_path.lower() or "msedge" in chrome_path.lower()) else "Chrome"
        
        if chrome_path:
            # Use Chrome/Edge directly
            print(f"Using {browser_name} to open VolumeLeaders...")
            
            # First check if we have stored window IDs from a previous run
            stored_data = get_stored_window_ids(system_type="windows")
            if stored_data and stored_data.get("window_ids"):
                existing_pids = stored_data.get("window_ids")
                browser_name = stored_data.get("browser", browser_name)
                
                print(f"Using {len(existing_pids)} stored browser windows with PIDs: {existing_pids}")
                
                # SIMPLIFIED APPROACH: Always close existing windows and open new ones
                # This is more reliable than trying to navigate existing windows
                ps_cmd = f'''
                $browserPids = "{','.join(str(pid) for pid in existing_pids)}".Split(",");
                $windows = @();
                foreach ($pid in $browserPids) {{
                    $process = Get-Process -Id $pid -ErrorAction SilentlyContinue;
                    if ($process) {{ $windows += $process }};
                }}
                
                Write-Host "Found $($windows.Count) browser processes out of $($browserPids.Length) stored IDs";
                
                # Close existing windows
                foreach ($window in $windows) {{
                    try {{
                        $window.CloseMainWindow() | Out-Null
                    }} catch {{
                        Write-Host "Failed to close a window"
                    }}
                }}
                
                # Give them time to close
                Start-Sleep -Seconds 1
                
                # Return the browser name we found
                if ($windows -and $windows.Count -gt 0) {{
                    if ($windows[0].Name -eq "chrome") {{
                        return "chrome"
                    }} else {{
                        return "msedge"
                    }}
                }}
                
                return "no_browser"
                '''
                
                result = subprocess.run(["powershell", "-Command", ps_cmd], capture_output=True, text=True)
                result_output = result.stdout.strip()
                
                # Clear stored window IDs since we closed those windows
                clear_stored_window_ids("windows")
                
                # Now we'll continue below to create new windows
            
            # Check for any existing browser windows first
            print("Checking for existing browser windows...")
            try:
                # This command detects ANY existing browser windows, not just volumeleaders ones
                ps_cmd = '''
                $allBrowserWindows = @();
                
                # Try to find Chrome windows
                try {
                    $chromeWindows = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | 
                        Where-Object {$_.MainWindowTitle -ne "" -and $_.MainWindowHandle -ne [IntPtr]::Zero};
                    
                    # If we have Chrome windows, prioritize those
                    if ($chromeWindows -and $chromeWindows.Count -ge 1) {
                        $allBrowserWindows = $chromeWindows;
                    }
                } catch {};
                
                # Only look for Edge windows if we don't have enough Chrome windows
                if ($allBrowserWindows.Count -lt 1) {
                    try {
                        $edgeWindows = Get-Process -Name "msedge" -ErrorAction SilentlyContinue | 
                            Where-Object {$_.MainWindowTitle -ne "" -and $_.MainWindowHandle -ne [IntPtr]::Zero}
                        if ($edgeWindows) {
                            $allBrowserWindows += $edgeWindows;
                        }
                    } catch {};
                }
                
                if ($allBrowserWindows -and $allBrowserWindows.Count -gt 0) {
                    # MODIFIED: Close existing windows instead of trying to reuse them
                    foreach ($window in $allBrowserWindows) {
                        try {
                            $window.CloseMainWindow() | Out-Null
                        } catch {
                            Write-Host "Failed to close a window"
                        }
                    }
                    
                    # Give them time to close
                    Start-Sleep -Seconds 1
                    
                    # Return browser name
                    if ($allBrowserWindows[0].Name -eq "chrome") {
                        return "chrome"
                    } else {
                        return "msedge"
                    }
                } else {
                    return ""
                }
                '''
                
                # Run PowerShell command
                result = subprocess.run(["powershell", "-Command", ps_cmd], capture_output=True, text=True)
                
                # Clear any stored window IDs since we're starting fresh
                clear_stored_window_ids("windows")
                
            except Exception as e:
                print(f"Error checking existing windows: {e}")
                print("Continuing with new windows...")
            
            # Start all browser processes and collect their PIDs
            print(f"Launching new {browser_name} windows...")
            processes = []
            processes.append(subprocess.Popen([chrome_path, "--new-window", url1]))
            time.sleep(1)  # Reduced delay
            processes.append(subprocess.Popen([chrome_path, "--new-window", url2]))
            time.sleep(1)
            processes.append(subprocess.Popen([chrome_path, "--new-window", url3]))
            time.sleep(1)
            processes.append(subprocess.Popen([chrome_path, "--new-window", url4]))
            
            # Get process IDs for positioning
            process_ids = [p.pid for p in processes]
            print(f"Browser process IDs: {process_ids}")
            
            # Store these PIDs for next time
            store_window_ids(process_ids, browser_name, "windows")
            
            # Give them a moment to start up
            print("Waiting for browser windows to initialize...")
            time.sleep(3)  # Reduced delay
            
            # Try to position windows
            try:
                print("Positioning windows...")
                position_windows_powershell(process_ids, chrome_path, [url1, url2, url3, url4])
            except Exception as e:
                print(f"Window positioning failed: {e}")
        else:
            print("Neither Chrome nor Edge found. Trying to use default browser...")
            # Try to use the default browser through Windows start command
            os.system(f'start "" "{url1}"')
            time.sleep(1)
            os.system(f'start "" "{url2}"')
            time.sleep(1)
            os.system(f'start "" "{url3}"')
            time.sleep(1)
            os.system(f'start "" "{url4}"')
            
            # Cannot position windows when using default browser
            print("Cannot position windows when using default browser")
            
    except Exception as e:
        print(f"Windows browser opening method failed: {e}")
        print("Falling back to simple browser opening method...")
        
        # Fallback to simple method with webbrowser module
        webbrowser.open(url1)
        webbrowser.open(url2)
        webbrowser.open(url3)
        webbrowser.open(url4)

def open_urls_parallels_wsl(url1, url2, url3, url4):
    """Open URLs when running in Parallels WSL environment."""
    try:
        print("Opening URLs in Windows browser under Parallels...")
        
        # Try to find Chrome in common Parallels Windows locations
        chrome_paths = [
            '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe',
            '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
            '/mnt/c/Users/*/AppData/Local/Google/Chrome/Application/chrome.exe',  # Wildcard path
            # Add more potential paths if needed
        ]
        
        browser_path = None
        browser_name = "Chrome"
        
        # First check exact paths for Chrome
        for path in chrome_paths:
            if '*' not in path and os.path.exists(path):
                browser_path = path
                print(f"Found Chrome at: {browser_path}")
                break
        
        # If not found, try expanding wildcards for Chrome
        if not browser_path:
            for path in chrome_paths:
                if '*' in path:
                    # Try to expand wildcard paths
                    matching_paths = glob.glob(path)
                    if matching_paths:
                        browser_path = matching_paths[0]
                        print(f"Found Chrome at: {browser_path}")
                        break
                        
        # If Chrome not found, try Microsoft Edge
        if not browser_path:
            print("Chrome not found. Looking for Microsoft Edge...")
            edge_paths = [
                '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe',
                '/mnt/c/Program Files/Microsoft/Edge/Application/msedge.exe',
                # Add more potential paths if needed
            ]
            
            for path in edge_paths:
                if os.path.exists(path):
                    browser_path = path
                    browser_name = "Edge"
                    print(f"Found Microsoft Edge at: {browser_path}")
                    break
        
        if browser_path:
            # Check for existing browser windows and close them
            print("Checking for existing browser windows...")
            
            # Close any existing browser windows - using a file instead of direct command to avoid quoting issues
            ps_script = '''
            $allBrowserWindows = @();
            
            # Get all Chrome windows
            try {
                $chromeWindows = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | 
                    Where-Object {$_.MainWindowTitle -ne "" -and $_.MainWindowHandle -ne [IntPtr]::Zero};
                
                # If we have Chrome windows, prioritize those
                if ($chromeWindows -and $chromeWindows.Count -ge 1) {
                    $allBrowserWindows = $chromeWindows;
                }
            } catch {}
            
            # Get all Edge windows
            try {
                $edgeWindows = Get-Process -Name "msedge" -ErrorAction SilentlyContinue | 
                    Where-Object {$_.MainWindowTitle -ne "" -and $_.MainWindowHandle -ne [IntPtr]::Zero}
                if ($edgeWindows) {
                    $allBrowserWindows += $edgeWindows;
                }
            } catch {}
            
            # Close all found windows
            if ($allBrowserWindows.Count -gt 0) {
                Write-Host "Closing $($allBrowserWindows.Count) existing browser windows"
                foreach ($window in $allBrowserWindows) {
                    try {
                        $window.CloseMainWindow() | Out-Null
                    } catch {
                        Write-Host "Failed to close a window"
                    }
                }
                
                # Give them time to close
                Start-Sleep -Seconds 1
            }
            '''
            
            # Write script to a temporary file
            temp_ps_file = "/tmp/vl_close_windows.ps1"
            with open(temp_ps_file, "w") as f:
                f.write(ps_script)
            
            # Execute the script file instead of passing the script directly
            cmd = f"cd /mnt/c && powershell.exe -ExecutionPolicy Bypass -File /mnt/c/Users/Public/vl_close_windows.ps1"
            
            # First copy the script to a Windows-accessible location
            shutil.copy(temp_ps_file, "/mnt/c/Users/Public/vl_close_windows.ps1")
            
            # Now execute it
            subprocess.run(cmd, shell=True)
            
            # Clean up the temp file
            try:
                os.remove(temp_ps_file)
                os.remove("/mnt/c/Users/Public/vl_close_windows.ps1")
            except:
                pass
            
            # Clear any stored window IDs
            clear_stored_window_ids("parallels_wsl")
            
            # Launch new browser windows with the correct URLs
            print(f"Launching {browser_name} windows...")
            
            # Use --new-window flag to force new windows instead of tabs
            processes = []
            processes.append(subprocess.Popen([browser_path, "--new-window", url1]))
            time.sleep(1)  # Reduced delay
            processes.append(subprocess.Popen([browser_path, "--new-window", url2]))
            time.sleep(1)
            processes.append(subprocess.Popen([browser_path, "--new-window", url3]))
            time.sleep(1)
            processes.append(subprocess.Popen([browser_path, "--new-window", url4]))
            
            # Get process IDs for positioning
            process_ids = [p.pid for p in processes]
            print(f"Browser process IDs: {process_ids}")
            
            # Store these window IDs for future use
            store_window_ids(process_ids, browser_name, "parallels_wsl")
            
            # Give them a moment to start up
            print("Waiting for browser windows to initialize...")
            time.sleep(3)  # Reduced delay
            
            # Try to position windows
            try:
                print("Positioning windows...")
                position_windows_powershell(process_ids, browser_path, [url1, url2, url3, url4])
            except Exception as e:
                print(f"Window positioning failed: {e}")
                
            return
            
        # If no browser found, try with PowerShell instead of cmd.exe
        print("No browser found, trying with PowerShell and default browser...")
        
        # Use PowerShell from C drive to avoid UNC path issues
        ps_commands = [
            f'Start-Process -WindowStyle Normal "{url1}"',
            f'Start-Process -WindowStyle Normal "{url2}"',
            f'Start-Process -WindowStyle Normal "{url3}"',
            f'Start-Process -WindowStyle Normal "{url4}"'
        ]
        
        # Change to C: drive first to avoid UNC path issues
        for cmd in ps_commands:
            try:
                # Run PowerShell with a CD command first to avoid UNC path issues
                full_cmd = f"cd /mnt/c && powershell.exe -Command \"{cmd}\""
                print(f"Running: {full_cmd}")
                subprocess.run(full_cmd, shell=True)
                time.sleep(1)
            except Exception as e:
                print(f"PowerShell command failed: {e}")
        
        # Cannot position windows when using default browser
        print("Cannot position windows when using default browser")
        
    except Exception as e:
        print(f"Parallels WSL browser opening method failed: {e}")
        print("Trying alternative methods...")
        
        try:
            # Try with explorer.exe as a last resort, with explicit path
            print("Trying explorer.exe with explicit C: drive path...")
            subprocess.run(["cd /mnt/c && explorer.exe", url1], shell=True)
            subprocess.run(["cd /mnt/c && explorer.exe", url2], shell=True)
            subprocess.run(["cd /mnt/c && explorer.exe", url3], shell=True)
            subprocess.run(["cd /mnt/c && explorer.exe", url4], shell=True)
            
        except Exception as e2:
            print(f"Alternative method failed: {e2}")
            print("Please manually open the following URLs in Windows browser:")
            print(f"URL 1: {url1}")
            print(f"URL 2: {url2}")
            print(f"URL 3: {url3}")
            print(f"URL 4: {url4}")

def open_urls_wsl(url1, url2, url3, url4):
    """Open URLs when running in WSL environment."""
    try:
        # Try to find browsers in Windows
        print("Looking for browsers in Windows...")
        
        # Try to find Chrome first in common Windows locations
        chrome_paths = [
            '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe',
            '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
            '/mnt/c/Users/*/AppData/Local/Google/Chrome/Application/chrome.exe',  # Wildcard path
        ]
        
        browser_path = None
        browser_name = "Chrome"
        
        # Check for Chrome
        for path in chrome_paths:
            if '*' not in path and os.path.exists(path):
                browser_path = path
                print(f"Found Chrome at: {browser_path}")
                break
                
        # Try wildcard paths for Chrome
        if not browser_path:
            for path in chrome_paths:
                if '*' in path:
                    matching_paths = glob.glob(path)
                    if matching_paths:
                        browser_path = matching_paths[0]
                        print(f"Found Chrome at: {browser_path}")
                        break
        
        # If Chrome not found, try Microsoft Edge
        if not browser_path:
            print("Chrome not found. Looking for Microsoft Edge...")
            edge_paths = [
                '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe',
                '/mnt/c/Program Files/Microsoft/Edge/Application/msedge.exe',
            ]
            
            for path in edge_paths:
                if os.path.exists(path):
                    browser_path = path
                    browser_name = "Edge"
                    print(f"Found Microsoft Edge at: {browser_path}")
                    break
        
        # If a browser was found, check for existing windows
        if browser_path:
            print(f"Checking for existing browser windows...")
            
            # Try to detect browser windows using PowerShell - using file approach to avoid quoting issues
            try:
                # Create a PowerShell script that closes existing browser windows
                ps_script = '''
                $allBrowserWindows = @();
                
                # Try to find Chrome windows
                try {
                    $chromeWindows = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | 
                        Where-Object {$_.MainWindowTitle -ne "" -and $_.MainWindowHandle -ne [IntPtr]::Zero};
                    
                    # If we have Chrome windows, prioritize those
                    if ($chromeWindows -and $chromeWindows.Count -ge 1) {
                        $allBrowserWindows = $chromeWindows;
                    }
                } catch {};
                
                # Only look for Edge windows if we don't have enough Chrome windows
                if ($allBrowserWindows.Count -lt 1) {
                    try {
                        $edgeWindows = Get-Process -Name "msedge" -ErrorAction SilentlyContinue | 
                            Where-Object {$_.MainWindowTitle -ne "" -and $_.MainWindowHandle -ne [IntPtr]::Zero}
                        if ($edgeWindows) {
                            $allBrowserWindows += $edgeWindows;
                        }
                    } catch {};
                }
                
                if ($allBrowserWindows -and $allBrowserWindows.Count -gt 0) {
                    # MODIFIED: Close existing windows instead of trying to reuse them
                    foreach ($window in $allBrowserWindows) {
                        try {
                            $window.CloseMainWindow() | Out-Null
                        } catch {
                            Write-Host "Failed to close a window"
                        }
                    }
                    
                    # Give them time to close
                    Start-Sleep -Seconds 1
                }
                '''
                
                # Write script to a temporary file
                temp_ps_file = "/tmp/vl_close_windows.ps1"
                with open(temp_ps_file, "w") as f:
                    f.write(ps_script)
                
                # Copy to a Windows-accessible location
                shutil.copy(temp_ps_file, "/mnt/c/Users/Public/vl_close_windows.ps1")
                
                # Execute the script file
                cmd = f"cd /mnt/c && powershell.exe -ExecutionPolicy Bypass -File C:\\Users\\Public\\vl_close_windows.ps1"
                subprocess.run(cmd, shell=True, capture_output=True, text=True)
                
                # Clean up the temp files
                try:
                    os.remove(temp_ps_file)
                    os.remove("/mnt/c/Users/Public/vl_close_windows.ps1")
                except:
                    pass
                
                # Clear any stored window IDs since we're starting fresh
                clear_stored_window_ids("wsl")
                
            except Exception as e:
                print(f"Error checking for browser windows: {e}")
                print("Continuing with new windows...")
            
            # Launch new browser windows with the correct URLs
            print(f"Launching {browser_name} windows...")
            
            # Use --new-window flag to force new windows instead of tabs
            processes = []
            processes.append(subprocess.Popen([browser_path, "--new-window", url1]))
            time.sleep(1)  # Reduced delay
            processes.append(subprocess.Popen([browser_path, "--new-window", url2]))
            time.sleep(1)
            processes.append(subprocess.Popen([browser_path, "--new-window", url3]))
            time.sleep(1)
            processes.append(subprocess.Popen([browser_path, "--new-window", url4]))
            
            # Get process IDs for positioning
            process_ids = [p.pid for p in processes]
            print(f"Browser process IDs: {process_ids}")
            
            # Give them a moment to start up
            print("Waiting for browser windows to initialize...")
            time.sleep(3)  # Reduced delay
            
            # Try to position windows
            try:
                print("Positioning windows...")
                position_windows_powershell(process_ids, browser_path, [url1, url2, url3, url4])
            except Exception as e:
                print(f"Window positioning failed: {e}")
                
            return
            
        # If no browser found, try to use powershell.exe to open URLs in the Windows host's browser
        print("No browser found, trying with PowerShell and default browser...")
        
        # Escape quotes in URLs for PowerShell
        ps_url1 = url1.replace('"', '\\"')
        ps_url2 = url2.replace('"', '\\"')
        ps_url3 = url3.replace('"', '\\"')
        ps_url4 = url4.replace('"', '\\"')
        
        # Change to C: drive first to avoid UNC path issues
        ps_commands = [
            f'Start-Process -WindowStyle Normal "{ps_url1}"',
            f'Start-Process -WindowStyle Normal "{ps_url2}"',
            f'Start-Process -WindowStyle Normal "{ps_url3}"',
            f'Start-Process -WindowStyle Normal "{ps_url4}"'
        ]
        
        for cmd in ps_commands:
            try:
                # Run PowerShell with a CD command first to avoid UNC path issues
                full_cmd = f"cd /mnt/c && powershell.exe -Command \"{cmd}\""
                print(f"Running: {full_cmd}")
                subprocess.run(full_cmd, shell=True)
                time.sleep(1)
            except Exception as e:
                print(f"PowerShell command failed: {e}")
        
        # Cannot position windows when using default browser
        print("Cannot position windows when using default browser")
        
    except Exception as e:
        print(f"WSL browser opening method failed: {e}")
        print("Trying alternative method...")
        
        try:
            # Try with explorer.exe as a last resort, with explicit path
            print("Trying explorer.exe with explicit C: drive path...")
            subprocess.run(["cd /mnt/c && explorer.exe", url1], shell=True)
            subprocess.run(["cd /mnt/c && explorer.exe", url2], shell=True)
            subprocess.run(["cd /mnt/c && explorer.exe", url3], shell=True)
            subprocess.run(["cd /mnt/c && explorer.exe", url4], shell=True)
            
        except Exception as e2:
            print(f"Alternative method failed: {e2}")
            print("Please manually open the following URLs:")
            print(f"URL 1: {url1}")
            print(f"URL 2: {url2}")
            print(f"URL 3: {url3}")
            print(f"URL 4: {url4}")

def open_urls_default(url1, url2, url3, url4):
    """Open URLs on other platforms using the default browser."""
    print("Opening URLs in default browser...")
    webbrowser.open(url1)
    time.sleep(1)
    webbrowser.open(url2)
    time.sleep(1)
    webbrowser.open(url3)
    time.sleep(1)
    webbrowser.open(url4)

if __name__ == "__main__":
    main() 